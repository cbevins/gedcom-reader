/**
 * Creates a Gedcom class instance from _gedcomData.js data.
 * (The _gedcomData.js file itself is generated by write_gedcomData.js from a GEDCOM text file from Ancestry.com or RootsMagic).
 *
 * While the existence of any specific set of GEDCOM record types is not assumed,
 * the following GEDCOM input file format rules are enforced:
 * - Every text line is a series of blank-separated fields
 * - Every text line has at least 2 fields
 * - The first field of every text line is a *level* number [0-n]
 * - If the second field is enclosed in '@' characters, it is a GEDCOM *key*, and the record *type* is then in the third field
 * - Otherwise, the second field is the GEDCOM record *type*
 * - Any fields after the record *type* field are all the record *content*
 */
import { Gedcom } from './Gedcom.js'

export class GedcomReader {
    constructor(_gedcomData) {
        this._data = {
            gedcomRecords: new Gedcom(),
            msg: []
        }
        for(let i=0; i<_gedcomData.length; i++) this._parseRecord(_gedcomData[i], i+1)
    }

    gedcom() { return this._data.gedcomRecords }

    messages() { return this._data.msg }

    _addMsg(msg) { this._data.msg.push(msg) }

    _isKey(field) { return field[0] === '@' }

    _parseRecord(line, lineNo) {
        let fields = line.split(' ')
        if (fields[0] === '') return
        if (fields.length < 2) {
            const msg = `Line ${lineNo} has just ${fields.length} fields: [${line}]`
            console.log(msg, fields)
            this._addMsg(msg)
            return
        }
        // First field must be a level integer (base 0)
        const level = Number(fields[0])

        // If the second field is a @A123@ style GEDCOM key field ...
        if (this._isKey(fields[1])) {
            // ... there must be a third field with the GedcomRecord *type* (like 'INDI' or 'FAM')
            if (fields.length < 3) {
                const msg = `Line ${lineNo} has a key field '${fields[1]}' but no type field`
                console.log('FATAL ERROR', msg)
                throw new Error(msg)
            }
            // (lineNo, level, type, content)
            this.gedcom()._addLine(lineNo, level, fields[2], fields[1])
        }
        // otherwise the second field is the GedcomRecord *type* and the remaining fields are the content
        else {
            let content = fields.length > 2 ? fields[2] : ''
            for(let i=3; i<fields.length; i++) content += ' ' + fields[i]
            // (lineNo, level, type, content)
            this.gedcom()._addLine(lineNo, level, fields[1], content)
        }
    }
}
