import fs from 'fs'
import { file2JsonArray } from '../index.js'
import { gedcomParseLine } from './gedcomParseLine.js'

function intFormat(val, width=4) { return val.toLocaleString('en-US').padStart(width) }

const fileName = '../data/RootsMagic.ged'   // './Sample.ged'
const outputName = 'Sample.js'

const time1 = new Date()
const lines = await file2JsonArray(fileName)
const time2 = new Date()
const gedcom = gedcomFile2Array(lines)
const time3 = new Date()
writeGedcomFile(gedcom, outputName)
const time4 = new Date()

console.log(`${fileName} with ${lines.length} lines has ${gedcom.length} records.`)
console.log(`file2JsonArray()  : ${intFormat(time2-time1)} msec`)
console.log(`gedcomFile2Array() : ${intFormat(time3-time2)} msec`)
console.log(`writeGedcomFile() : ${intFormat(time4-time3)} msec`)

function writeGedcomFile(gedcom, outputName) {
    // Create some Javascript from the text array
    let js = `// auto-generated by gedcomFile2Array.js on ${new Date().toLocaleString()}\n`
    js += `export const gedcom = [\n`
    for(let i=0; i<gedcom.length; i++) {
        js += JSON.stringify(gedcom[i]) + ',\n'
    }
    js += ']\n'

    // Write the Javascript to a file for later use
    fs.writeFile(outputName, js, function (err) {
        if (err) throw err
    })
}

// Returns an array of records from the GEDCOM file
function gedcomFile2Array(lines) {
    // Each record is an array of:
    const INDEX = 0     // rec[INDEX] is the records index in the GEDCOM array
    const LINENO = 1    // rec[LINENO] is the original GEDCOM file line number
    const LEVEL = 2     // rec[LEVEL] is the base 0 record hierarchical level
    const TYPE = 3      // rec[TYPE]
    const CONTENT = 4   // rec[CONTENT]
    const PARENT = 5    // rec[PARENT] contains index of parent, or 0 if no parent (level 0)
    const CHILDREN = 6  // rec[CHILDREN] contains a (possibly empty) array of child indixes

    const ar = [[0, 0, -1, '', '', 0, []]]
    let prevRec = ar[0]
    const stack = []
    for(let i=0; i<lines.length; i++) {
        const data = gedcomParseLine(lines[i], i+1)
        // Handle errors
        if (data.error) console.log(data.msg)
        if (data.error === 2) throw new Error(data.msg)
        
        // If 'CONC', simply append content to the current record
        if (data.type === 'CONC') {
            prevRec[CONTENT] += data.content
        }
        // If 'CONT', append both a newline and new content to the current record
        else if (data.type === 'CONT') {
            prevRec[CONTENT] += '/n' + data.content
        }
        // else this is a new record
        else {
            data.index = ar.length
            data.children = []
            if (data.level > prevRec[LEVEL]) {          // If this records descends a LEVEL...
                data.parent = prevRec[INDEX]                // make the previous record this record's PARENT
            } else if (data.level === prevRec[LEVEL]) { // Else if this record is at the same LEVEL as the previous record ...
                data.parent = prevRec[PARENT]               // this record has the same PARENT as the previous record
            } else {                                    // If this record ascends 1 OR MORE LEVELs...
                for(let idx=data.index-1; idx>=0; idx-=1) {  // Traverse up the array until we find the parent
                    if (ar[idx][LEVEL] === data.level-1) {  // If the upper record is one at the LEVEL above this record...
                        data.parent = ar[idx][INDEX]        // set the upper record as this record's PAREMT
                        break
                    }
                }
            }
            // console.log(lines[i], data)
            // const p = ar[data.parent]
            // console.log(`LINE ${data.lineNo} '${data.level} ${data.type}' PARENT IS LINE ${p[LINENO]} '${p[LEVEL]} ${p[TYPE]}'`)
            ar[data.parent][CHILDREN].push(data.index)  // add this record to the parent record's CHILDREN
            ar.push([data.index, data.lineNo, data.level, data.type, data.content, data.parent, data.children])
            prevRec = ar[ar.length-1]
        }
    }
    // for(let i=0; i<ar.length; i++) ar[i][CONTENT] = JSON.stringify(ar[i][CONTENT])
    return ar
}
